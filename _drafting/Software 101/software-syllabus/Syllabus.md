---
tags: software101, engineering, syllabus
---
### Syllabus
The goal of the Software Engineering degree is to produce a software engineer who can rapidly assume a position of substantial responsibility within an organization. To achieve this goal, the curriculum must be designed to give the student a strong foundation of knowledge and practical skills that includes the software engineering process activities, software development lifecycle, various software development methodologies and tools, so they can develop quality products that meet the need of users.

#### First year (General knowledge & Comprehension)
a.     Programming language and data structure. (Skills)
b.     Software process (Knowledge)
c.      Software Lifecycle (The evolution of software) Waterfall, Incremental, Spiral, Agile etc.
d.     Software methods (various method concepts from design, code, reuse, parallel etc.)
e.      Software maintenance (Modify, adaptive, corrective etc.)
f.       Technical communication (Soft-skills) writing, reading, terminology, presentation etc.

#### Second year (General knowledge & Comprehension)
a.     Programming language (Skills)
b.     Software configuration management and software quality assurance (Support activities)
c.      Software Testing (Several concepts and test methods)
d.     Software project management (planning, and monitoring etc.)
e.      Software economics (Estimates, budget, plan, track etc.)
f.       Software operation (Issues, personnel, risks etc.)

#### Third year (Application, synthesis, analysis)
a.     Requirements Engineering (Analysis, specification, customer relations, market analysis)
b.     Architecture & Design (Specification, plan, design, interfaces, quality attributes etc.)
c.      Implementation (A mini project to practice from req. to code, each week is review a topic in each phase)
d.     Measurement & Metrics (data collection and analysis, action, reports, status, quality etc.)
e.      Integration (How to put everything together)
f.       Database or embedded (Choice between two area)

#### Fourth year (Mostly Practicum – Evaluation and integration)
a.     Capstone (Real project given by industry)
b.     Soft-skills (Several workshops with various topics)
c.      Market & industry trends (Read news and discuss)

### CMU’s SWE curriculum
#### The Software Engineering Process
* Topics: The software engineering process and software products. All of the software engineering activities. The concepts of software process model and software product life cycle model. The disciplines and benefits of following a defined process.
* Aspects: All aspects, as appropriate for the various activities.
* Objectives: Knowledge of activities and aspects. Some comprehension of the issues, especially the distinctions among the various classes of activities. The students should begin to understand the substantial differences between programming, and software engineering, as it is practiced professionally in the industry.


#### Software Evolution (Lifecycle)
* Topics: The concept of a software product life cycle. The various forms of a software product, from initial conception through development and operation to retirement. Controlling activities and disciplines to support evolution. Planned and unplanned events that affect software evolution. The role of changing technology.
* Aspects: Models of software evolution, including development life cycle models such as the waterfall, iterative enhancement, phased development, spiral.
* Objectives: Knowledge and comprehension of the models. Knowledge and comprehension of the controlling activities. Students should know all phases of the lifecycle in details and be able to follow it from requirements to retirement of software products.


#### Software Generation (Models and Methods)
* Topics: Various methods of software generation, including designing and coding from scratch, use of reusable components (including examples such as Mathematical procedure libraries, packages designed specifically for reuse, generic program units, open source software, and program concatenation as with pipes, use of program or application generators and very high level languages, role of prototyping. Factors affecting choice of a software generation method. Effects of generation method on other software development activities, such as testing and maintenance.
* Aspects: Models of software generation. Representations for software generation, including design and implementation languages, very high level Languages, and application generators. Tools to support generation methods, including application generators.
* Objectives: Knowledge and comprehension of the various methods of software generation. Ability to apply each method when supported by appropriate tools. Ability to evaluate methods and choose the appropriate ones for each project.


#### Software Maintenance
* Topics: Maintenance as a part of software evolution. Reasons for maintenance. Kinds of maintenance (perfective, adaptive, corrective). Comparison of development activities during initial product development and during maintenance. Controlling activities and disciplines that affect maintenance. Designing for maintainability. Techniques for maintenance.
* Aspects: Models of maintenance. Current methods.
* Objectives: Knowledge and comprehension of the issues of software maintenance and current maintenance practice.


#### Technical Communication (Soft-skills)
* Topics: Fundamentals of technical communication. Oral and written communications. Preparing oral presentations and supporting materials. Software project documentation of all kinds. Teamwork communication, public speaking, presentation skills.
* Aspects: Principles of communication. Document preparation tools. Standards for presentations and documents.
* Objectives: Knowledge of fundamentals of technical communication and of software documentation. Application of fundamentals to oral and written communications. Ability to analyze, synthesizes, and evaluates technical communications.


#### Software Configuration Management
* Topics: Concepts of configuration management. Its role in controlling software evolution. Maintaining product integrity. Change control and version control. Organizational structures for configuration management.
* Aspects: Fundamental principles. Tools. Documentation, including configuration management plans.
* Objectives: Knowledge and comprehension of the issues. Ability to apply the knowledge to develop a configuration management plan and to use appropriate tools.


#### Software Quality Issues
* Topics: Definitions of quality. Factors affecting software quality. Planning for quality. Quality concerns in each phase of a software life cycle, with special emphasis on the specification of the pervasive system attributes. Quality measurement and standards. Software correctness assessment principles and methods. The role of formal verification and the role of testing. Secure coding, security as quality.
* Aspects: Assessment of software quality: appropriate measures. Tools to help perform measurement. Correctness assessment methods, including testing and formal verification. Formal models of program verification.
* Objectives: Knowledge and comprehension of software quality issues and correctness methods. Ability to apply proof of correctness methods.


#### Software Quality Assurance
* Topics: Software quality assurance as a controlling discipline. Organizational structures for quality assurance. Independent verification and validation teams. Test and evaluation teams. Software technical reviews. Software quality assurance plans.
* Aspects: Current industrial practice for quality assurance. Documents including quality assurance plans, inspection reports, audits, and validation test reports.
* Objectives: Knowledge and comprehension of quality assurance planning. Ability to analyze and synthesize quality assurance plans. Ability to perform technical reviews. Knowledge and comprehension of the fundamentals of program verification, and its role in quality assurance. Ability to apply concepts of quality assurance as part of a quality assurance team.


#### Software Project Organizational and Management Issues
* Topics: Project planning: choice of process model, project scheduling and milestones. Staffing: development team organizations, quality assurance teams. Resource allocation.
* Aspects: Fundamental concepts and principles. Scheduling representations and tools. Project documents.
* Objectives: Knowledge and comprehension of concepts and issues. It is not expected that a student, after studying this material, will immediately be ready to manage a software project but understand the concept. They need additional trainings by taking additional courses in software economics, operational issues,


#### Software Project Economics
* Topics: Cost estimation, cost/benefit analysis, risk analysis for software projects. Factors that affect cost. Budgeting, planning and manage software in workplaces. Differences between private companies and government offices, public and private areas, small and large business.
* Aspects: Models of cost estimation. Current techniques and tools for cost estimation.
* Objectives: Knowledge and comprehension of models and techniques. Ability to apply the knowledge to tool use.


#### Software Operational Issues
* Topics: Organizational issues related to the use of a software system in an organization. Training, system installation, system transition, operation, retirement. User documentation.
* Aspects: User documentation and training materials.
* Objectives: Knowledge and comprehension of the major issues.


#### Requirements Engineering 1 (Analysis)
* Topics: The process of interacting with the customer to determine system requirements. Defining software requirements. Identifying functional, performance, and other requirements: the pervasive system requirements. Techniques to identify requirements, including prototyping, modeling, and simulation.
* Aspects: Principles and models of requirements. Techniques of requirement identification. Tools to support these techniques, if available. Assessing requirements. Communication with the customer.
* Objectives: Knowledge and comprehension of the concepts of requirements analysis and the different classes of requirements. Knowledge of requirements analysis techniques. Ability to apply techniques and analyze and synthesize requirements for simple systems.


#### Requirements Engineering 2 (Specification)
* Topics: Objectives of the specification process. Form, content, and users of a specifications document. Specifying functional, performance, reliability, and other requirements of systems. Formal models and representations of specifications. Specification standards.
* Aspects: Formal models and representations. Specification techniques and tools that support them, if available. Assessment of a specification for attributes such as consistency and completeness. Specification documents.
* Objectives: Knowledge and comprehension of the fundamental concepts of specification. Knowledge of specification models, representations, and techniques, and the ability to apply or use one or more. Ability to analyze and synthesize a specification document for a simple system


#### System Architect
* Topics: The role of system architect and software design. How architecture fits into a life cycle. Software as a component of a system. Hardware vs. software; trade-offs for system performance and flexibility. Subsystem definition and design. Design of high level interfaces, both hardware to software and software to software.
* Aspects: System modeling techniques and representations. Methods for system design, including object oriented design, and tools to support those methods. Iterative design techniques. Performance prediction.
* Objectives: Comprehension of the issues in system design, emphasizing engineering trade-offs. Ability to use appropriate system design models, methods, and tools, including those for specifying interfaces. Ability to analyze and synthesize small systems.


#### Software Design
* Topics: Principles of design, including abstraction and information hiding, modularity, reuse, prototyping° Levels of design. Design representations. Design practices and techniques. Examples of design paradigms for well understood systems.
* Aspects: Principles of software design. One or more design notations or languages. One or more widely used design methods and supporting tools, if available. Assessment of the quality of a design. Design documentation.
* Objectives: Knowledge and comprehension of one or more design representations, design methods, and supporting tools, if available. Ability to analyze and synthesize designs for software systems. Ability to apply methods and tools as part of a design team.


#### Software Implementation
* Topics: Relationship of design and implementation. Features of modern procedural languages related to design principles. Implementation issues including reusable components and application generators. Programming support environment concepts.
* Aspects: One or more modern implementation languages and supporting tools. Assessment of implementations: coding standards and metrics
* Objectives: Ability to analyze, synthesize, and evaluate the implementation of small systems.


#### Software Testing
* Topics: The role of testing and its relationship to quality assurance. The nature of and limitations of testing. Levels of testing: unit, integration, acceptance, etc. Detailed study of testing at the unit level. Formal models of testing. Test planning. Black box and white box testing. Building testing environments. Test case generation. Test result analysis.
* Aspects: Testing principles and models. Tools to support specific kinds of tests. Assessment of testing; testing standards. Test documentation.
* Objectives: Knowledge and comprehension of the role and limitations of testing. Ability to apply test tools and techniques. Ability to analyze test plans and test results. Ability to synthesize a test plan.


#### System Integration
* Topics: Testing at the software system level. Integration of software and hardware components of a system. Uses of simulation for missing hardware components. Strategies for gradual integration and testing.
* Aspects: Methods and supporting tools for system testing and system integration. Assessment of test results and diagnosing system faults. Documentation: integration plans, test results.
* Objectives: Comprehension of the issues and techniques of system integration. Ability to apply the techniques to do system integration and testing. Ability to develop system test and integration plans. Ability to interpret test results and diagnose system faults.


#### Embedded Real-time Systems
* Topics: Characteristics of embedded real-time systems. Existence of hard timing requirements. Concurrency in systems and representing concurrency in requirements specifications, designs, and code. Issues related to complex interfaces between devices and between software and devices. Criticality of embedded systems and issues of robustness, reliability, and fault tolerance. Input and output considerations, including unusual data representations required by devices. Issues related to the cognizance of time. Issues related to the inability to test systems adequately.
* Objectives: Comprehension of the significant problems in the analysis, design, and construction of embedded real-time systems. Ability to produce small systems that involve interrupt handling, low level input and output, concurrency, and hard timing requirements, preferably in a high level language.


#### Human Interfaces
* Topics: Software engineering factors: applying design techniques to human interface problems, including concepts of device independence and virtual terminals. Human factors: definition and effects of screen clutter, assumptions about the class of users of a system, robustness and handling of operator input errors, uses of color in displays.
* Objectives: Comprehension of the major issues. Ability to apply design techniques to produce good human interfaces. Ability to design and conduct experiments with interfaces, to analyze the results, and to improve the design as a result.


### Project Experience Component
Project work (Capstone) is essential to developing software engineering skills. We recommend that approximately 30% of students’ time be devoted to realistic project work. This curriculum component can be structured in a number of ways. By the time students enter third year, they need to start working on small projects in a teamwork environment. This is good to use agile approach to allow them to complete small project in about three to six weeks. By the time they enter the last year, it is important to capstone project that covers most of the coursework, where they learn full development with all lifecycle phases in details. Capstone need to be developed cooperative with industry.